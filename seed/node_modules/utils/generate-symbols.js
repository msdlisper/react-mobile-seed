/**
 * @file generate symbol svg and css file
 * @author CaiYu
 */

const fs = require('fs');
const cheerio = require('cheerio');
const path = require('path');

/**
 * handle each svg file, structured data
 *
 * @param {string} file , svg file path
 * @param {Object} opts, options object
 * @return {{}} return object that contains some useful attributes
 */
function handleEachFile(file, opts) {

    const replaceTag = '%f';
    const ext = '.svg';
    const result = {};

    const matchIdTag = opts.id || replaceTag;
    const matchClassNameTag = opts.className || replaceTag;

    const content = fs.readFileSync(file).toString();
    const $ = cheerio.load(content, {
        normalizeWhitespace: true,
        xmlMode: true
    });

    const $svg = $('svg');
    const attr = $svg[0].attribs;
    const name = path.basename(file, ext);

    const reg = new RegExp(replaceTag);

    result.id = matchIdTag.replace(reg, name);
    result.className = matchClassNameTag.replace(reg, name);
    result.viewBox = attr.viewBox;
    result.width = sizeOrViewboxFallback(attr.width, attr.viewBox.split(' ')[2]);
    result.height = sizeOrViewboxFallback(attr.height, attr.viewBox.split(' ')[3]);

    // style
    const $style = $svg.find('style');
    result.style = $style.html();
    $style.remove();

    // handle <g> tag
    $svg.find('g').each(function () {
        const $this = $(this);
        if (!$this.children().length) {
            $this.remove();
        }
    });

    // handle <defs> tag
    const $defs = $svg.find('defs');
    if ($defs.children().length) {
        result.defs = $defs.html();
    }
    $defs.remove();

    result.content = $svg.html();

    return result;

}

/**
 * style handle
 *
 * @param {Object} rawData  each svg element raw data
 * @return {string} style string
 */
function handleStyle(rawData) {
    let multiplePathStyle = '';
    let singlePathStyle = '';
    const n = '\n';
    const match = rawData.style.match(/\.(\D)/g);
    if (match.length > 1) {
        multiplePathStyle = rawData.style.replace(/\.(\D)/g, '\n' + rawData.className + ' .$1');
    } else {
        const property = rawData.style.match(/[a-z|-]*:[#|\w|\.]*/g);
        property.forEach(function (item) {
            // 去除默认颜色填充, 自定义fill color
            if (/fill:/.test(item)) {
                return;
            }
            singlePathStyle = singlePathStyle + '  ' + item + ';' + n;
        });
    }
    const style = rawData.className + '{' + n
        + '  ' + 'width: ' + rawData.width + 'px;' + n
        + '  ' + 'height: ' + rawData.height + 'px;' + n
        + singlePathStyle
        + '}'
        + multiplePathStyle
        + n
        + n;
    return style;
}

/**
 * generate symbol element of each svg element
 *
 * @param {Object} rawData  each svg element raw data
 * @param {Object} opts options object
 * @return {string} symbol html string
 */
function generateSymbol(rawData, opts) {

    const $ = cheerio.load('<symbol></symbol>', {xmlMode: true, ignoreWhitespace: true});
    const $symbol = $('symbol');

    $symbol.attr('id', rawData.id);
    $symbol.attr('viewBox', rawData.viewBox);
    $symbol.addClass(rawData.id + ' svg-symbol');
    $symbol.append(rawData.content);
    $symbol.append(rawData.defs);
    return $.html();
}

/**
 * 相对路径转换为绝对路径
 *
 * @param {string} p relative path
 * @return {string|*} returns an absolute path
 */
function absolutePath(p) {
    const directory = path.dirname(module.parent.filename);
    return path.join(directory, p);
}

/**
 * Gets the initial size of the SVG Icon
 *
 * @param {string|number} size, svg ele attribute size
 * @param {string|number} fallback, viewBox size
 * @return {*} return size of svg icon
 */
function sizeOrViewboxFallback(size, fallback) {
    if (typeof size === 'undefined') {
        return fallback;
    }
    if (/\d+%/.test(size)) {
        return (parseInt(size, 10) * fallback) / 100;
    }
    return parseInt(size, 10);
}

/**
 * Is it an absolute path
 *
 * @param {string} path path of judgment
 * @return {boolean} return true or false
 */
function isAbsolutePath(path) {
    return !/^\./.test(path);
}

const g = function (opts) {

    let files = [];
    let style = '';
    if (Object.prototype.toString.call(opts.file) === '[object Array]') {
        files = opts.file;
    }

    if (typeof opts.file === 'string') {
        const isMultiple = /\*/.test(opts.file) || !/\*\.svg/.test(opts.file);
        if (isMultiple) {
            const relativePath = opts.file.replace(/\*\.svg/, '');
            const directoryPath = isAbsolutePath(relativePath) ? relativePath : absolutePath(relativePath);
            const svgList = fs.readdirSync(directoryPath);
            files = svgList.map(function (filename) {
                return path.join(relativePath, filename);
            });
        } else {
            files.push(opts.file);
        }
    }

    const $ = cheerio.load('<svg></svg>', {xmlMode: true, ignoreWhitespace: true});
    const xmlns = 'http://www.w3.org/2000/svg';
    const $svg = $('svg');
    const destDir = isAbsolutePath(opts.dest) ? opts.dest : absolutePath(opts.dest);

    $svg.attr('xmlns', xmlns);

    if (opts.svgClassname) {
        $svg.addClass(opts.svgClassname);
    }

    files.forEach(function (file) {
        const path = isAbsolutePath(file) ? file : absolutePath(file);
        // 只处理svg文件
        if (!/\.svg\b/.test(path)) {
            return;
        }
        const rawData = handleEachFile(path, opts);
        const symbolString = generateSymbol(rawData, opts);
        const cssString = rawData.style ? handleStyle(rawData) : '';

        style += cssString;
        $svg.append(symbolString);
    });

    fs.writeFileSync(path.join(destDir, opts.svgFileName), $.html());
    fs.writeFileSync(path.join(destDir, opts.cssFileName), style);
};

module.exports = g;